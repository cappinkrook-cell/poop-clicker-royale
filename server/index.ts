import express from 'express'; import cors from 'cors'; import { createServer } from 'http'; import { Server } from 'socket.io'; const app=express(); app.use(cors({origin:(process.env.CORS_ORIGIN?.split(',') as any)||'*'})); app.get('/',(_req,res)=>res.send('Poop Clicker Royale server OK')); const httpServer=createServer(app); const io=new Server(httpServer,{cors:{origin:(process.env.CORS_ORIGIN?.split(',') as any)||'*'}}); type Spawn={id:string,x:number,y:number,v:number,t:number,claimed?:boolean}; type RoomState={name:string,scores:Record<string,number>,items:Map<string,Spawn>,users:Map<string,{name:string}>,phase:'playing'|'intermission',endsAt:number,timer?:NodeJS.Timeout,spawner?:NodeJS.Timeout}; const rooms=new Map<string,RoomState>(); function getRoom(name:string):RoomState{ if(!rooms.has(name)){ const rs:RoomState={name,scores:{},items:new Map(),users:new Map(),phase:'intermission',endsAt:Date.now()}; rooms.set(name,rs); startIntermission(rs);} return rooms.get(name)!;} function uid(){ return Math.random().toString(36).slice(2,9);} function startIntermission(r:RoomState){ r.phase='intermission'; r.items.clear(); io.to(r.name).emit('intermission',{msg:'New round in 5sâ€¦',scores:r.scores}); clearTimers(r); r.endsAt=Date.now()+5000; r.timer=setTimeout(()=>startRound(r),5000) as any;} function startRound(r:RoomState){ r.phase='playing'; r.scores={}; r.items.clear(); r.endsAt=Date.now()+30000; io.to(r.name).emit('start',{msg:'Go!'}); clearTimers(r); r.spawner=setInterval(()=>spawnOne(r),600) as any; r.timer=setInterval(()=>tick(r),250) as any; setTimeout(()=>endRound(r),30000);} function endRound(r:RoomState){ clearTimers(r); r.phase='intermission'; io.to(r.name).emit('intermission',{msg:'Round over!',scores:r.scores}); setTimeout(()=>startRound(r),5000);} function clearTimers(r:RoomState){ if(r.timer) clearInterval(r.timer as any); if(r.spawner) clearInterval(r.spawner as any); r.timer=undefined; r.spawner=undefined;} function spawnOne(r:RoomState){ if(r.phase!=='playing') return; const id=uid(); const x=30+Math.random()*(800-60); const y=30+Math.random()*(480-60); const value=[1,1,1,1,2,3,4,5][Math.floor(Math.random()*8)]; const t=Date.now(); const s:Spawn={id,x:Math.round(x),y:Math.round(y),v:value,t}; r.items.set(id,s); io.to(r.name).emit('spawn',s); setTimeout(()=>{ const it=r.items.get(id); if(it && !it.claimed){ r.items.delete(id); io.to(r.name).emit('despawn',id);} },2500);} function tick(r:RoomState){ const timeLeft=Math.max(0,(r.endsAt-Date.now())/1000); const items=Array.from(r.items.values()); io.to(r.name).emit('tick',{timeLeft,items,scores:r.scores,room:r.name,state:r.phase}); } io.on('connection',(socket)=>{ let room='global'; let name='Player_'+uid().slice(0,6); let rs=getRoom(room); function join(newRoom:string){ socket.leave(room); room=newRoom||'global'; rs=getRoom(room); socket.join(room); rs.users.set(socket.id,{name}); } socket.on('join',({name:n,room:rname}:{name:string,room:string})=>{ if(n) name=n.slice(0,14); join(rname||'global'); }); socket.on('rename',({name:n}:{name:string})=>{ name=(n||name).slice(0,14); const u=rs.users.get(socket.id); if(u) u.name=name; }); socket.on('request_state',()=>{ const timeLeft=Math.max(0,(rs.endsAt-Date.now())/1000); socket.emit('tick',{timeLeft,items:Array.from(rs.items.values()),scores:rs.scores,room:rs.name,state:rs.phase}); }); socket.on('hit',({id}:{id:string})=>{ const it=rs.items.get(id); if(!it || it.claimed || rs.phase!=='playing') return; it.claimed=true; rs.items.delete(id); rs.scores[name]=(rs.scores[name]||0)+it.v; io.to(room).emit('claimed',{who:name,id,scores:rs.scores}); }); socket.on('disconnect',()=>{ rs.users.delete(socket.id); }); }); const port=Number(process.env.PORT||8080); httpServer.listen(port,()=>console.log('Server listening on',port));